<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vector: Vector Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vector
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">AcontiguousgrowablegenerictypearrayinC.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Vector Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A generic and dynamic container that expands automatically as elements are added. The maximum storage capacity is (2^(sizeof(int) * 8 - 1)) / v-&gt;size_ele * 8 [vector_Max_capacity].  
 <a href="structVector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8h_source.html">vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a55870593ddea19c96770c2521b075059"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVector.html#a55870593ddea19c96770c2521b075059">len</a></td></tr>
<tr class="separator:a55870593ddea19c96770c2521b075059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc10ac30895378eed4f5b07edfdaaf62"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVector.html#abc10ac30895378eed4f5b07edfdaaf62">data</a></td></tr>
<tr class="separator:abc10ac30895378eed4f5b07edfdaaf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d49b240ab4a8ccb9b1c7297e78511da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVector.html#a6d49b240ab4a8ccb9b1c7297e78511da">capacity</a></td></tr>
<tr class="separator:a6d49b240ab4a8ccb9b1c7297e78511da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff3b09498f43b6d1225b70c76428921"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVector.html#a4ff3b09498f43b6d1225b70c76428921">ele_size</a></td></tr>
<tr class="separator:a4ff3b09498f43b6d1225b70c76428921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878f53535bc6a2f2dcbed86cc993216c"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVector.html#a878f53535bc6a2f2dcbed86cc993216c">compar</a> )(const void *, const void *)</td></tr>
<tr class="separator:a878f53535bc6a2f2dcbed86cc993216c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780c3355a80ed925d0e2255f67027a63"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVector.html#a780c3355a80ed925d0e2255f67027a63">Destroy</a> )(struct <a class="el" href="structVector.html">Vector</a> *v)</td></tr>
<tr class="separator:a780c3355a80ed925d0e2255f67027a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9780a6781c0d08a0a1b2c614abdd1a"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVector.html#a7d9780a6781c0d08a0a1b2c614abdd1a">Destroy_pointer</a> )(struct <a class="el" href="structVector.html">Vector</a> *v)</td></tr>
<tr class="separator:a7d9780a6781c0d08a0a1b2c614abdd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efc2de85653a5aeefb0b1059a1ada76"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVector.html#a2efc2de85653a5aeefb0b1059a1ada76">Destroy_slice</a> )(struct <a class="el" href="structVector.html">Vector</a> *v)</td></tr>
<tr class="separator:a2efc2de85653a5aeefb0b1059a1ada76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A generic and dynamic container that expands automatically as elements are added. The maximum storage capacity is (2^(sizeof(int) * 8 - 1)) / v-&gt;size_ele * 8 [vector_Max_capacity]. </p>
<p>The library supports amortized constant time insertion and removal of elements , as well as constant time access.</p>
<p>The object provided by the <a class="el" href="structVector.html" title="A generic and dynamic container that expands automatically as elements are added. The maximum storage...">Vector</a> library is an array type container that:</p>
<ol type="1">
<li>It only must contain addresses of HEAP. The insertion must be done by calling the Memory Manager, that is: any new insertion will have to be done with pointers to HEAP.<ol type="a">
<li>Resides in contiguous memory, accessible by arithmetic of pointers</li>
<li>It is generic: it supports any types: we identifie the information not by its type, but by its size</li>
<li>The object resides in HEAP</li>
<li>The object is self-expanding: doubles its capacity automatically if the insertion of a new element requires it</li>
<li>The library provides insertion of items from file.</li>
</ol>
</li>
</ol>
<pre class="fragment">          The insertion of elements is always by reference. If the item
          were created in main, (reside in STACK) the object pointed by
          our stored direction, is released when the application finishes.
          There is nothing to free.

          But if you create the element by calling the Memory Manager
          (calloc,  * malloc, ...) then the pointer resides in the HEAP, and
          must be released before application has finished.

         This means that either we create data that resides in STACK or
         we create it by calling the memory manager. If both forms
         are combined  then we release a STACK direction with the call
         to Destroy, and this will cause a segment violation, or any other
         undefined behavior. Or, if we do not call Destroy, we will leave
         pointers without releasing when our application has returned
         (memory - leak).

         If the insertion is made from function calls, you must only insert
         elements whose addresses reside in HEAP, since the space in
         the stack corresponding to the function is released once it
         returns.

         Well, our object only must contain addresses of HEAP.
         The insertion must be done  by calling the Memory Manager
         before. That is: any new insertion will have to be done with
         pointers to HEAP.

         The contract is:

         1. Only insert references to HEAP
         2. Who calls the Memory Manager, free the direction stored in
             the pointer.

         If we follow the rules, there will be no problem: neither
         memory leak, neither double free.</pre> </div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a6d49b240ab4a8ccb9b1c7297e78511da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d49b240ab4a8ccb9b1c7297e78511da">&#9670;&nbsp;</a></span>capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Vector::capacity</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Capacity, in number of elements. Capacity has to be greater than Zero </p>

</div>
</div>
<a id="a878f53535bc6a2f2dcbed86cc993216c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878f53535bc6a2f2dcbed86cc993216c">&#9670;&nbsp;</a></span>compar</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* Vector::compar) (const void *, const void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparing Function pointer </p>

</div>
</div>
<a id="abc10ac30895378eed4f5b07edfdaaf62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc10ac30895378eed4f5b07edfdaaf62">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Vector::data</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Array to hold the information </p>

</div>
</div>
<a id="a780c3355a80ed925d0e2255f67027a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780c3355a80ed925d0e2255f67027a63">&#9670;&nbsp;</a></span>Destroy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* Vector::Destroy) (struct <a class="el" href="structVector.html">Vector</a> *v)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<a id="a7d9780a6781c0d08a0a1b2c614abdd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9780a6781c0d08a0a1b2c614abdd1a">&#9670;&nbsp;</a></span>Destroy_pointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* Vector::Destroy_pointer) (struct <a class="el" href="structVector.html">Vector</a> *v)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor to use with the function vector_Insert_from_file. It frees the pointers created and then it calls Destroy </p>

</div>
</div>
<a id="a2efc2de85653a5aeefb0b1059a1ada76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efc2de85653a5aeefb0b1059a1ada76">&#9670;&nbsp;</a></span>Destroy_slice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* Vector::Destroy_slice) (struct <a class="el" href="structVector.html">Vector</a> *v)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<a id="a4ff3b09498f43b6d1225b70c76428921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff3b09498f43b6d1225b70c76428921">&#9670;&nbsp;</a></span>ele_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Vector::ele_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structVector.html" title="A generic and dynamic container that expands automatically as elements are added. The maximum storage...">Vector</a>'s data type. It has to be the returned value of 'sizeof(<a class="el" href="structVector.html" title="A generic and dynamic container that expands automatically as elements are added. The maximum storage...">Vector</a>'s data type)'</p>
<p>The constructor requires that the client element size be identified up front.</p>
<p>Since it doesn’t (and will never) know the true data type, it needs the size so it at least knows how many bytes to replicate behind the scenes with every call to manage data. </p>

</div>
</div>
<a id="a55870593ddea19c96770c2521b075059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55870593ddea19c96770c2521b075059">&#9670;&nbsp;</a></span>len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Vector::len</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of elements in <a class="el" href="structVector.html" title="A generic and dynamic container that expands automatically as elements are added. The maximum storage...">Vector</a> object </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/<a class="el" href="vector_8h_source.html">vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
